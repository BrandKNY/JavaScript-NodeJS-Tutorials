# 000-Starting-Point

## Roadmap and Goals of tutorials

#### Goals
The goals of these tutorials will be to cover the JavaScript language and also cover the foundations for NodeJS development. The primary focus is JavaScript as a language. It could be taught using just a browser with the console open in the developer tools window - and at times that will be used as well. However, I felt it would be easier and more constructive to be able to run JavaScript from the command-line, from executable nodejs files, and from within an IDE with a debugger.

I plan to cover the language using ES6 standards. This includes:
- Classes with constructors, extends, and calls to super constructors
- Map and Set Classes
- Arrow functions (and subsequently *scopes*)
- Promises
- Let and Const
- Map-Reduce and Array.map (these aren't really new, but they're improved)

While covering these concepts I will likely show how those things were traditionally accomplished in <= ES5 standards, and explain the benefits (or drawbacks). At times I may draw some parallels to Java as well to compare and contrast, which may be helpful to those with knowledge of Java who are migrating over to learning JavaScript now.

#### Software and dependencies
- **Operating Systems**: NodeJS can run on any of the 3 major desktop OSes (Windows, Mac OS X, and Linux variants) - however I will be using Ubuntu 16.04  (Linux) for the duration of these tutorials. It is possible I will put together an additional tutorial video showing how to setup your environment with NodeJS and NPM on Mac OSx and Windows if there is enough demand for it. Alternatively, if you have one of those two systems but want to use Linux to follow along exactly you have the option of setting up your system to dual-boot with Linux, or alternatively to use Virtualization Platforms like Virtualbox to create and setup a VM running Ubuntu Linux inside your existing OS (granted you have 8GB or more RAM available on your system this is probably the easier solution). I have some older tutorials I put together a few years ago that cover all of this. The playlist for those tutorials can be [found here on YouTube](https://www.youtube.com/watch?v=rDkfEoAEKp4&list=PLKYLJoiyP2a5GEmUH4W58nw8-9-UFv65R) (probably checkout videos 1, 3, 4, 5 for relevance to this).

- **IDE**: I will be making use of Jetbrains Webstorm IDE for the tutorials. It is a paid IDE with a free-trial period. It was possible to continue using the software after the trial period although there were some limitations (such as needing to restart it ever 30 minutes or something along those line). I am not sure if that is still the case or what the limitations are at this point as I use a paid version. Atom is an alternative which I will explore and cover setting up if I decide it will be useful for people watching at home to use without needing to pay. I will look into the debugging capabilities which are the important feature I want to make use of for tutorials and teaching purposes (and the reason I will be using Webstorm).

- **Packages/Software**: NodeJS and NPM. Also it will be helpful to have a browser such as Chromium or Google Chrome (preferred), or Firefox, or Opera.

- **Version Control Software**: This is not very important as you can simply download code and example files from this repository using a browser to retrieve files/ZIP archives. However it is probably easier to handle it with **Git**. Plus it is in your best interest to familiarize yourself with some VCS system, and Git is at the forefront in that category. It is very likely that I will be putting together a separate tutorial series on using Git, so I will update this block with a reference link to it once it is up and running.

## Brief Histories and Background Info

#### Definition for JavaScript:

`a high-level, dynamic, untyped, and interpreted programming language.`

-  **high-level** - Abstraction separates the language from the *low-level* components and hardware of the underlying system; rather than dealing with cpu registers, memory addresses, and call-stacks directly, the language provides *variables, arrays, objects, arithmetic operators, boolean expressions, functions, and flow-control statements* (among other things) for the programmer to work with.
- **dynamic** - opposes to *compiled* languages (e.g. Java, C); Dynamic languages perform many operations at **runtime** execution which are typically handled during the **compile-time** stage for a *static / compiled* languages.
- **untyped** - another way of saying *dynamically typed*; Variables must be declared but are not defined as being bound to a particular type. `var foo = "bar" // Javascript variable is a string based on its value type` This is opposite of a *static typed* language (e.g. Java) where you declare your variables and their type when you initialize them. `String foo = "bar" // Java variable is declared to be a String explicitly`. Note that errors with variables containing values that do not adhere to the variable's declared *type* will be caught and thrown at compile time for statically typed languages, but this is not the case with Javascript as it is a dynamic and dynamically-typed language.
- **interpreted** - somewhat ties in with *dynamic* in that the code is not compiled to machine code before execution; Javascript code is processed by the engine and runtime while it executes which means there is more overhead due to on-the-fly parsing/translation (slower performance compared with compiled machine code execution).
- **Weak vs Strong Typing** - Javascript is **weak typed** (and dynamically typed), similarly to other languages like PHP. This means that a variable is not strictly bound to its type. (Although we don't need to declare our variable types when we initialize them, they take on a *type* dynamically depending on the value assigned).
  - *Weak typed*: For example, what the code below shows is that a Number and a String are able to be concatenated together and assigned to a new variable. The behavior can be tricky at times and differs by language.
    - `var x = 2; // here typeof(x) === 'number'`
    - `var y = 'hello'; // here typeof(y) === 'string'`
    - `var z = (x + y); // here typeof(z) === 'string' and value: 'hello2'`
    - `z = 5; // now typeof(z) === 'number' with value: 5`  
  - *Strong typed*: the above code would cause an error in a strongly typed language such as Java; Since a variable is declared with a specific type in strongly-typed languages, it must always contain values of that type. It would be possible to use *Coercion* to transform a value from one type into another (e.g. `String z = Number.toString(5)`).

#### History Time-line

- Originally created by Brendan Eich (allegedly in just 10 days) for Netscape Communications (Mosaic Netscape) for use in their web browser circa 1995. Goal was to prototype a complementary scripting language similar in syntax to Sun's Java language. Development name was "mocha", released as "LiveScript", and renamed to "JavaScript".

- Server-side scripting with JavaScript was available as early as 1995 as well, however it really never caught on until recently with the release of NodeJS.

- *Ecma International* standards organization (formerly named European Computer Manufacturers Association) took on a proposal to standardize the language; In 1997 they published their ECMA-262 standard named "ECMAScript (ES)". Implementations of this standard now include: JavaScript, JScript, and ActionScript

- In 2009 Ryan Dahl released the initial version of NodeJS Runtime Environment for Linux systems to provide server-side Javascript execution using Google's V8 Javascript Engine.

- In 2011 ECMAScript 5.1 is finalized as a standard. This is the version still widely used today as the transition to adopt and support ECMAScript 6 is ongoing

- In June 2015 ECMAScript 6 (a.k.a ES6, ECMAScript 2015, ES2015, ECMAScript Harmony, and ES6 Harmony) was released. There are a large number of additions and changes to the language including support for *classes* and *modules*.

- Currently not all browsers have adopted full compatibility support for every feature of ES6, and legacy versions of browsers definitely will not be able to interpret the language properly. To handle this it is common for developers to write ES6 code and use special compiler tools to **transpile** (essentially *translate*) the code backward to ES5 standards. Notable among these tools are *webpack* and *babel* with their various plugins.

- Many features and concepts have been proposed and discussed for the future release of the language - ES7. Some of these features were already heavily discussed for ES6 but did not make it into the standard to allow a timely release of the finalized features. Nonetheless, some developers have begun using some of these features by creating libraries that implement them as well as transpiler plugins to support their use in modern JavaScript runtimes.

- As of this writing NodeJS stable release is version 6.7.0. It supports the majority of ES6 (ES 2015) features. A breakdown of this support by NodeJS version can be [found here at node.green](http://node.green/)

#### A little bit about Server-side JavaScript with NodeJS

- **Note**: What follows here is a loose overview of some concepts concerning NodeJS. I anticipate covering all of these concepts in much more detail during the individual tutorials that cover them, so don't get too stuck or confused on their details yet.

- **Why?**: Going back prior to 2009 (before NodeJS) - most websites were generally built on (but not strictly limited to) back-end systems running either PHP or Java code. The problem with these systems is that they handled client connections using *blocking I/O* - that is, a client would make a TCP connection to the server on a socket and the server would handle that entire request-response communication on a forked process (or a thread). Forking processes and threading requires system resources and overhead (CPU cycles and RAM) dedicated to each one, and therefor there is a strict limitation to how many concurrent connections (requests and clients) that can be handled at a given time. This presents a *scalability* problem - one which generally is solved by throwing more hardware at it as a solution (meaning more physical servers and more RAM which equate to higher costs). At the heart of this problem, however, was the fact that while a client had issued a request and the server was handling it on a process/thread, it was put in a *blocking* state - meaning nothing else could be processed while that *blocking* state was set. Furthermore, and most importantly, the *vast majority* of the lifecycle for these threads/processes were actually spend in a waiting state.

- **An analogy for Blocking-I/O**: To clarify on this - imagine you have a business that has a call center with 5 incoming phone lines to take calls from customers (This would be like the max number of processes/threads attached to sockets for incoming requests on a server). You have 100 personnel workers that can do work to process requests by the customers who call - things like retrieving files of information from shelves, calculating some results, figuring out solutions to problems, checking inventory for requested items, etc... (this would be like the overall processing power of the server itself which is pretty powerful). In a *blocking I/O* model what it is basically saying is that a caller will connect to one of your workers on one of the 5 phone lines and ask for something - let's say they need the worker to locate their physical file folder in the backroom (database) and to calculate the total sum of some data in their file and respond with that total. The *blocking I/O* model means the worker answers the call, takes the request and puts the customer on-hold while they perform that work required to respond. The customer is now sitting on hold for 5 minutes while the worker carries out the task. Meanwhile that phone line is tied up and cannot be used to take new requests from other customers. It also means that of your 100 workers, only 5 of them are being used efficiently while the other 95 are just sitting around idle. Only after the information requested has been returned to the customer and the call is terminated can a new request come in on that line. Now image that to handle 10 incoming customer calls your solution is to build an entire new call center (server) with its own set of 100 employees and 5 incoming phone lines.

- **Non-Blocking I/O Analogy**: Building off our blocking-i/o analogy above, let's now consider how NodeJS approaches this problem. NodeJS says we're going to have a call center with a single incoming phone line. However, rather than letting one employee tie up that line for the full duration of a request, it says we'll handle everything asynchronously. A customer will call in and make a request and the worker will take the customer's phone number and say "Go do other things and we'll call you back with the result when it is ready" and then hang up. That worker goes about looking up the information and crunching the numbers, while the phone line is now free for a new customer to call in and make a new request to a different employee. Suddenly all of your 100 employees are actually being given tasks efficiently. When a result is ready, the worker uses the callback number to return the result.

- **How does all of this work?**: NodeJS uses something called the *event loop* which operates on a single-thread of your server only. This loop is somewhat like a conveyor-belt or a water-mill (water wheel). That is - certain processes, function calls, or tasks are loaded onto the loop and executed at some point down the line. Tasks can be separated and scheduled onto different iterations of this loop. A task is usually associated with some *callback* function that basically says (when you're done with this task schedule the next *tick* to run its callback, or next-step). This introduces a new approach to programming which can be tricky for those who are new to it and are used to traditional synchronous blocks of code. With asynchronous code a developer must take care to ensure that they do not try to use results of a process in a synchronous manner. If we piggyback on the examples used above - if I am the client and I make a request (a function call) that should return some result, just because I hung up the phone upon making the request does not mean I have the result I need already. If I intend to use the result of the first request as an argument to a second function (request) then it is possible, in fact very likely, that the second function is going to throw an error or fail to run as expected because the argument will be undefined. Rather I would have to say "Request some data A from function X, and when it is ready THEN use it to request some processing from function Y using that result". There are multiple different ways to handle this asynchronously: You could call function X and pass in function Y as the callback parameter (and function X would need to expect that one of it's parameters is going to be a callback function that will be invoked at the end with the result of its own operations); You could use a library to make async code behave more synchronously such as that *async* npm module in nodejs; You could use the new features of ES6 called Promises or the ES7 features known as *async-await* declarations.

- **Benefits of Server-side JavaScript**: One of the major benefits of having the same language running on your Server-Side as you do on your Client-Side (browser) is the ability to re-use code and re-use developers for both approaches. Rather than having a developer need to switch contexts between, say, PHP and Javascript - now they can simply operate in one language across the full-stack. This also means the code base for both the client and the server can actually make use of classes and libraries that abstract to cover both. For example - if you have a site that implements some validation rules - methods/functions that define and check rules on valid characters of usernames, password strength rules, etc.. - normally you would want to do this on *both* the client-side and the server-side. This means you may have written your client Javascript library to implement these rules, and also duplicate this code in PHP for the server to do the same. Should you decide to update the rules you use for validation you would need to update your PHP and your Javascript libraries to do so, and ensure that both of them implement the rules the same way. Now, however, you could write a single Class with methods that implement these rules in JavaScript, and import that class to your Client page and also import it to your NodeJS server-side code which is guaranteed to consistently give the same result on both. It is both easier to maintain and laves you with a smaller overall codebase.

- **Drawbacks of NodeJS**: Asynchronous code can be quite difficult to keep clean and debug. As the complexity grows, it is possible to get very confused while handling what has been dubbed "Callback Hell". However, the addition of Promises can drastically simplify the clarity/readability of the code in my experience. Furthermore, while NodeJS is very efficient at handling a large number of requests/responses simultaneously, it is still operating on a single thread. If any of your tasks (methods/routines) are extremely complex in terms of processing overhead (extremely complex number crunching, for example) then it will still block the rest of the tasks on the loop for that single thread until it has completed. This means that very complicated, high-CPU intensive routines are not best-handled with NodeJS. One could mitigate this problem by using NodeJS in a clustered, multi-threaded way, or by off-loading longer processes to worker threads either using NodeJS or a different language, such as Java. This could start to approach a back-end that resembles that of a microservices architecture.

#### Clarifying on some NodeJS & JavaScript ecosystem related things

- **[Coffee Script](http://coffeescript.org/)**: a pseudo-JavaScript language that compiles back to regular JavaScript. The idea was to make the language simpler to write in a more human-readable style/syntax which, in many ways, seems somewhat *Python*-like. Some people love it, some people hate it. Personally, I am not a fan of using it but hold no judgments against those who do enjoy it. However I would say learn the ins-and-outs of JavaScript as a whole before diving into a superset of the language.

- **[TypeScript](http://www.typescriptlang.org/)**: similar to CoffeeScript in being a superset, pseudo-language form of JavaScript which ultimately compiles back down into JavaScript. Allegedly it was designed with *.NET* developers in mind to allow them to work with JavaScript in a more familiar and friendly manner to what they were accustomed to in order to boost their productivity.

- **[Babel](https://babeljs.io/)**: an open-source middleware system built on stacks of plugins that enable *language interoperability*. It stretches far beyond just the JavaScript community and handles libraries written in C/C++, Fortran, Python, and Java as well - and it does so on all POSIX and Unix variants (Linux, Mac OS X, AIX, IRIX, Solaris, Tru64, Cray XT4, IBM Blue Gene) as well as GNU, Intel, IBM, PathScale, PGI, and other compilers. In summary - Babel is a beast.

- **[Webpack](https://webpack.github.io/)**: In their own words - "webpack takes modules with dependencies and generates static assets representing those modules." Webpack can - and often is - combined with Babel for JavaScript development.

- **[V8 JavaScript Engine](https://en.wikipedia.org/wiki/V8_(JavaScript_engine))**: JavaScript Engine developed for Chromium Project (Chromium Browser, Google Chrome Browser); Used as the main foundation for the NodeJS runtime and has been used for no-sql databases such as MongoDB and Couchbase. (As of version MongoDB >= v3.1.7 they use an alternative engine called *SpiderMonkey* which is used in Mozilla's Firefox browser)

- **[NPM](https://www.npmjs.com/)**: package management system for JavaScript (initially NodeJS but it can be used for a more agnostic approach including for packaged front-end development now as well). Published packages, referred to as modules, are easily installed to projects using NPM command-line system for simplified dependency management. The packages are published to an NPM repository which can be public such as for open-source, community driven packages, or private repositories for proprietary packages. One can host their own NPM server repository using server software such as *[Sinopia](https://github.com/rlidwka/sinopia)*. For those coming from other languages this can be thought of as similar to *Maven* (for Java), *Pear* and *Composer* (PHP).
